<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Cutter & Rearranger</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for responsiveness and appearance */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align to top to give more space for content */
            padding: 1rem;
            box-sizing: border-box; /* Include padding in element's total width and height */
        }
        .container {
            background-color: #ffffff;
            border-radius: 1rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            max-width: 1200px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            align-items: center;
        }
        .canvas-section {
            display: flex;
            flex-direction: column; /* Default to column for small screens */
            gap: 1.5rem;
            width: 100%;
            justify-content: center;
            align-items: center;
        }

        @media (min-width: 1024px) { /* On large screens, arrange side-by-side */
            .canvas-section {
                flex-direction: row;
                align-items: flex-start; /* Align canvases at the top */
            }
        }

        canvas {
            border: 2px solid #cbd5e1; /* slate-300 */
            border-radius: 0.75rem; /* rounded-xl */
            background-color: #f8fafc; /* slate-50 */
            max-width: 100%;
            height: auto; /* Maintain aspect ratio */
            touch-action: none; /* Prevent browser touch actions like scrolling/zooming */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08);
        }
        #mainCanvas {
            cursor: crosshair;
        }
        #arrangementCanvas {
            background-color: #fff; /* Clear background for arrangement */
        }

        .action-buttons button {
            transition: background-color 0.2s ease, transform 0.1s ease;
        }
        .action-buttons button:hover {
            transform: translateY(-2px);
        }
        .action-buttons button:active {
            transform: translateY(0);
        }
        /* Message Box Styling */
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 20px 30px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
            text-align: center;
            animation: fadeIn 0.3s ease-out;
            max-width: 90%;
        }

        .message-box button {
            padding: 8px 20px;
            background-color: #4f46e5;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .message-box button:hover {
            background-color: #4338ca;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -60%); }
            to { opacity: 1; transform: translate(-50%, -50%); }
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }
        .info-panel {
            background-color: #e0e7ff; /* indigo-100 */
            border-radius: 0.5rem;
            padding: 1rem;
            max-height: 200px; /* Limit height */
            overflow-y: auto; /* Make scrollable */
            white-space: pre-wrap; /* Preserve whitespace and allow wrapping */
            font-family: monospace;
            font-size: 0.9em;
            color: #312e81; /* indigo-900 */
            border: 1px solid #a5b4fc; /* indigo-300 */
        }
        .info-panel h3 {
            font-weight: bold;
            margin-bottom: 0.5rem;
            color: #4338ca; /* indigo-700 */
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen bg-gray-100 p-4">
    <div class="container">
        <h1 class="text-3xl font-bold text-gray-800 mb-4">Image Cutter & Rearranger</h1>

        <!-- File Upload Section -->
        <div class="w-full text-center mb-6">
            <label for="imageUpload" class="block text-lg font-medium text-gray-700 mb-2">Upload an Image:</label>
            <input type="file" id="imageUpload" accept="image/*" class="block w-full text-sm text-gray-500
                file:mr-4 file:py-2 file:px-4
                file:rounded-full file:border-0
                file:text-sm file:font-semibold
                file:bg-indigo-50 file:text-indigo-700
                hover:file:bg-indigo-100"/>
        </div>

        <!-- Canvas Section -->
        <div class="canvas-section lg:flex-row">
            <div class="flex flex-col items-center flex-1">
                <h2 class="text-xl font-semibold text-gray-700 mb-2">Draw on Original Image:</h2>
                <canvas id="mainCanvas"></canvas>
            </div>
            <div class="flex flex-col items-center flex-1">
                <h2 class="text-xl font-semibold text-gray-700 mb-2">Arrange Pieces Here:</h2>
                <canvas id="arrangementCanvas"></canvas>
                <p class="text-gray-500 text-sm mt-2">Drag pieces from the info panel into this canvas to arrange.</p>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="action-buttons flex flex-wrap justify-center gap-4 mt-6 w-full">
            <button id="cutButton" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-full shadow-lg transition-all text-lg disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                Cut Selected Area
            </button>
            <button id="saveAllButton" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-full shadow-lg transition-all text-lg disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                Save All Pieces
            </button>
             <button id="downloadArrangementButton" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-full shadow-lg transition-all text-lg disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                Download Arrangement
            </button>
            <button id="resetButton" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-full shadow-lg transition-all text-lg disabled:opacity-50 disabled:cursor-not-allowed">
                Reset
            </button>
        </div>

        <!-- Extracted Pieces Information Panel -->
        <div class="w-full mt-8">
            <h2 class="text-xl font-semibold text-gray-700 mb-4 text-center">Extracted Piece Information:</h2>
            <div id="pieceInfoPanel" class="info-panel shadow-inner">
                <p class="text-gray-500 text-center w-full">Cut a piece to see its SVG data and average color here. Drag piece info to arrange it on the right canvas.</p>
            </div>
        </div>
    </div>

    <script>
        // Get references to DOM elements
        const imageUpload = document.getElementById('imageUpload');
        const mainCanvas = document.getElementById('mainCanvas');
        const arrangementCanvas = document.getElementById('arrangementCanvas');
        const cutButton = document.getElementById('cutButton');
        const saveAllButton = document.getElementById('saveAllButton');
        const downloadArrangementButton = document.getElementById('downloadArrangementButton');
        const resetButton = document.getElementById('resetButton');
        const pieceInfoPanel = document.getElementById('pieceInfoPanel');

        const mainCtx = mainCanvas.getContext('2d');
        const arrangementCtx = arrangementCanvas.getContext('2d');

        // Global variables for image and drawing state
        let originalImage = null;
        let drawing = false;
        let currentPath = []; // Stores points for the current drawing path on mainCanvas (scaled coords)
        let allPaths = [];    // Stores all completed paths (scaled coords)

        // Stores all extracted pieces for arrangement, each object contains:
        // { id: uniqueId, imageDataUrl: string, imageObject: Image,
        //   originalPath: Array<Object>, averageColor: string, x: number, y: number, width: number, height: number }
        let extractedPiecesData = [];

        // Variables for drag-and-drop on arrangementCanvas
        let draggedPieceId = null; // ID of the piece currently being dragged
        let dragOffsetX, dragOffsetY; // Offset from mouse/touch to piece's top-left corner
        let lastHoveredElement = null; // For visual feedback during dragging pieces from info panel

        const SNAPPING_THRESHOLD = 20; // Pixels for snapping

        /**
         * Displays a custom message box to the user instead of alert().
         * @param {string} message - The message to display.
         * @param {string} type - Type of message (e.g., 'info', 'error').
         * @returns {Promise<void>} - A promise that resolves when the message box is closed.
         */
        function showMessageBox(message, type = 'info') {
            return new Promise(resolve => {
                // Create overlay to dim background
                const overlay = document.createElement('div');
                overlay.className = 'overlay';
                document.body.appendChild(overlay);

                // Create message box
                const messageBox = document.createElement('div');
                messageBox.className = 'message-box';
                messageBox.innerHTML = `
                    <p class="text-lg font-medium">${message}</p>
                    <button id="messageBoxOkButton" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded">OK</button>
                `;
                document.body.appendChild(messageBox);

                // Add event listener to OK button
                const okButton = document.getElementById('messageBoxOkButton');
                okButton.onclick = () => {
                    document.body.removeChild(messageBox);
                    document.body.removeChild(overlay);
                    resolve();
                };
            });
        }


        /**
         * Resets the application to its initial state.
         */
        function resetApp() {
            originalImage = null;
            drawing = false;
            currentPath = [];
            allPaths = [];
            extractedPiecesData = [];

            // Clear canvases
            mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
            mainCanvas.width = 0;
            mainCanvas.height = 0;

            arrangementCtx.clearRect(0, 0, arrangementCanvas.width, arrangementCanvas.height);
            arrangementCanvas.width = 0;
            arrangementCanvas.height = 0;

            pieceInfoPanel.innerHTML = '<p class="text-gray-500 text-center w-full">Cut a piece to see its SVG data and average color here. Drag piece info to arrange it on the right canvas.</p>';
            
            cutButton.disabled = true;
            saveAllButton.disabled = true;
            downloadArrangementButton.disabled = true;
            imageUpload.value = ''; // Clear file input
            showMessageBox('Application reset successfully!', 'info');
        }

        /**
         * Draws the original image onto the main canvas, scaling to fit.
         * Sets up the arrangement canvas to match original image dimensions.
         */
        function setupCanvases() {
            if (!originalImage) return;

            // --- Main Canvas (for drawing) ---
            const maxWidth = mainCanvas.parentElement.clientWidth;
            const maxHeight = window.innerHeight * 0.5; // Max 50% of viewport height for one canvas

            let scaledWidth = originalImage.width;
            let scaledHeight = originalImage.height;

            // Scale down if image is too large for drawing canvas
            if (scaledWidth > maxWidth) {
                scaledHeight = (scaledHeight / scaledWidth) * maxWidth;
                scaledWidth = maxWidth;
            }
            if (scaledHeight > maxHeight) {
                scaledWidth = (scaledWidth / scaledHeight) * maxHeight;
                scaledHeight = maxHeight;
            }

            mainCanvas.width = scaledWidth;
            mainCanvas.height = scaledHeight;
            mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
            mainCtx.drawImage(originalImage, 0, 0, mainCanvas.width, mainCanvas.height);
            mainCtx.strokeStyle = '#4f46e5'; // Indigo-600 for drawing
            mainCtx.lineWidth = 3;
            mainCtx.lineJoin = 'round';
            mainCtx.lineCap = 'round';
            mainCtx.globalAlpha = 0.7; // Slightly transparent drawing

            // --- Arrangement Canvas ---
            // This canvas should match the original image's dimensions for accurate placement of pieces
            arrangementCanvas.width = originalImage.width;
            arrangementCanvas.height = originalImage.height;
            arrangementCtx.clearRect(0, 0, arrangementCanvas.width, arrangementCanvas.height);
            
            // Ensure arrangement canvas is visible for drag-and-drop
            if (originalImage.width > 0 && originalImage.height > 0) {
                 downloadArrangementButton.disabled = false;
                 // Add an initial message or visual cue for the arrangement canvas if empty
                 if (extractedPiecesData.length === 0) {
                     arrangementCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                     arrangementCtx.font = '20px Inter';
                     arrangementCtx.textAlign = 'center';
                     arrangementCtx.fillText('Drag pieces here from the left panel', arrangementCanvas.width / 2, arrangementCanvas.height / 2);
                 }
            } else {
                 downloadArrangementButton.disabled = true;
            }
        }

        /**
         * Redraws all completed paths on the main canvas.
         */
        function redrawMainCanvasPaths() {
            mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height); // Clear canvas
            mainCtx.drawImage(originalImage, 0, 0, mainCanvas.width, mainCanvas.height); // Redraw original image

            mainCtx.beginPath();
            allPaths.forEach(path => {
                if (path.length > 0) {
                    mainCtx.moveTo(path[0].x, path[0].y);
                    for (let i = 1; i < path.length; i++) {
                        mainCtx.lineTo(path[i].x, path[i].y);
                    }
                    if (path.length > 2) { // Close path if it's a polygon
                        mainCtx.lineTo(path[0].x, path[0].y); // Close path to starting point
                    }
                }
            });
            mainCtx.stroke();
        }

        /**
         * Redraws all extracted pieces on the arrangement canvas.
         */
        function redrawArrangementCanvas() {
            arrangementCtx.clearRect(0, 0, arrangementCanvas.width, arrangementCanvas.height);
            if (extractedPiecesData.length === 0 && originalImage) {
                 arrangementCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                 arrangementCtx.font = '20px Inter';
                 arrangementCtx.textAlign = 'center';
                 arrangementCtx.fillText('Drag pieces here from the left panel', arrangementCanvas.width / 2, arrangementCanvas.height / 2);
            }

            extractedPiecesData.forEach(piece => {
                if (piece.imageObject && piece.x !== undefined && piece.y !== undefined) {
                    arrangementCtx.drawImage(piece.imageObject, piece.x, piece.y, piece.width, piece.height);
                }
            });
        }

        /**
         * Handles image file selection and loads it onto the canvas.
         * @param {Event} e - The file input change event.
         */
        imageUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        originalImage = img;
                        setupCanvases(); // Setup both canvases
                        cutButton.disabled = false;
                        saveAllButton.disabled = false;
                        resetButton.disabled = false;
                        pieceInfoPanel.innerHTML = '<p class="text-gray-500 text-center w-full">Draw on the image to cut pieces!</p>';
                    };
                    img.onerror = () => {
                        showMessageBox('Could not load image. Please try a different file.', 'error');
                        resetApp();
                    };
                    img.src = event.target.result;
                };
                reader.onerror = () => {
                    showMessageBox('Error reading file. Please try again.', 'error');
                    resetApp();
                };
                reader.readAsDataURL(file);
            } else {
                // If no file is selected, effectively reset state related to image
                resetApp();
            }
        });

        /**
         * Gets the mouse/touch coordinates relative to the canvas.
         * @param {Event} event - The mouse or touch event.
         * @param {HTMLCanvasElement} canvas - The canvas element to get coordinates from.
         * @returns {Object} - An object with x and y coordinates.
         */
        function getCanvasCoordinates(event, canvas) {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;

            // Check if it's a touch event
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            return {
                x: (clientX - rect.left) * (canvas.width / rect.width),
                y: (clientY - rect.top) * (canvas.height / rect.height)
            };
        }

        /**
         * Converts scaled canvas coordinates to original image coordinates.
         * @param {Object} scaledCoords - {x, y} coordinates on the scaled canvas.
         * @returns {Object} - {x, y} coordinates on the original image.
         */
        function toOriginalImageCoords(scaledCoords) {
            if (!originalImage || !mainCanvas.width || !mainCanvas.height) {
                return scaledCoords;
            }
            const scaleX = originalImage.width / mainCanvas.width;
            const scaleY = originalImage.height / mainCanvas.height;
            return {
                x: scaledCoords.x * scaleX,
                y: scaledCoords.y * scaleY
            };
        }

        /**
         * Starts drawing on the main canvas.
         * @param {Event} e - The mouse or touch event.
         */
        function startDrawing(e) {
            if (!originalImage) {
                showMessageBox('Please upload an image first!', 'error');
                return;
            }
            drawing = true;
            currentPath = []; // Start a new path
            const coords = getCanvasCoordinates(e, mainCanvas);
            currentPath.push(coords);
            mainCtx.beginPath();
            mainCtx.moveTo(coords.x, coords.y);
            e.preventDefault(); // Prevent default touch behavior (scrolling, zooming)
        }

        /**
         * Continues drawing on the main canvas.
         * @param {Event} e - The mouse or touch event.
         */
        function draw(e) {
            if (!drawing) return;
            const coords = getCanvasCoordinates(e, mainCanvas);
            currentPath.push(coords);
            mainCtx.lineTo(coords.x, coords.y);
            mainCtx.stroke();
            e.preventDefault();
        }

        /**
         * Ends drawing on the main canvas and closes the path.
         */
        function endDrawing() {
            if (!drawing) return;
            drawing = false;

            // If the path has at least 3 points, close it to form a shape
            if (currentPath.length > 2) {
                mainCtx.lineTo(currentPath[0].x, currentPath[0].y); // Connect last point to first
                mainCtx.stroke(); // Draw the closing line
                allPaths.push([...currentPath]); // Store a copy of the completed path
                // Show a temporary visual indication that path is closed, e.g., fill it briefly
                mainCtx.save();
                mainCtx.fillStyle = 'rgba(79, 70, 229, 0.2)'; // Faint indigo fill
                mainCtx.fill();
                mainCtx.restore();
            } else {
                // If path is too short to form a shape, discard it visually
                showMessageBox('Please draw a path with at least 3 points to form a cuttable shape.', 'info');
                redrawMainCanvasPaths(); // Clear incomplete drawing
            }
        }

        // Mouse events for drawing on main canvas
        mainCanvas.addEventListener('mousedown', startDrawing);
        mainCanvas.addEventListener('mousemove', draw);
        mainCanvas.addEventListener('mouseup', endDrawing);
        mainCanvas.addEventListener('mouseout', () => {
            // End drawing if mouse leaves canvas, but only if a path was being drawn
            if (drawing) {
                endDrawing();
            }
        });

        // Touch events for drawing on main canvas
        mainCanvas.addEventListener('touchstart', startDrawing);
        mainCanvas.addEventListener('touchmove', draw);
        mainCanvas.addEventListener('touchend', endDrawing);
        mainCanvas.addEventListener('touchcancel', endDrawing); // Handle touch being cancelled


        /**
         * Extracts the image region defined by the last drawn path, calculates average color,
         * and prepares data for SVG recreation.
         */
        cutButton.addEventListener('click', async () => {
            if (!originalImage || allPaths.length === 0) {
                showMessageBox('Please upload an image and draw a path first!', 'error');
                return;
            }

            const path = allPaths.pop(); // Take the last drawn path (scaled coordinates)
            if (path.length < 3) {
                showMessageBox('Cannot cut. A valid closed shape requires at least 3 points.', 'error');
                redrawMainCanvasPaths();
                return;
            }

            // Create a temporary offscreen canvas for clipping
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = mainCanvas.width;
            tempCanvas.height = mainCanvas.height;
            const tempCtx = tempCanvas.getContext('2d');

            // Draw the path as a clipping mask
            tempCtx.beginPath();
            tempCtx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) {
                tempCtx.lineTo(path[i].x, path[i].y);
            }
            tempCtx.closePath();
            tempCtx.clip(); // Apply the clipping mask

            // Draw the original image within the clipped region (scaled version)
            tempCtx.drawImage(originalImage, 0, 0, tempCanvas.width, tempCanvas.height);

            // Get the bounding box of the drawn path to crop the extracted image
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            path.forEach(p => {
                minX = Math.min(minX, p.x);
                minY = Math.min(minY, p.y);
                maxX = Math.max(maxX, p.x);
                maxY = Math.max(maxY, p.y);
            });

            // Add some padding to the bounding box to ensure the full clipped shape is captured
            const padding = 5; // Pixels
            minX = Math.max(0, minX - padding);
            minY = Math.max(0, minY - padding);
            maxX = Math.min(tempCanvas.width, maxX + padding);
            maxY = Math.min(tempCanvas.height, maxY + padding);

            const width = maxX - minX;
            const height = maxY - minY;

            if (width <= 0 || height <= 0) {
                showMessageBox('The drawn shape is too small or invalid for cutting.', 'error');
                redrawMainCanvasPaths();
                return;
            }

            // Create another temporary canvas for the final cropped piece
            const finalPieceCanvas = document.createElement('canvas');
            finalPieceCanvas.width = width;
            finalPieceCanvas.height = height;
            const finalPieceCtx = finalPieceCanvas.getContext('2d');

            // Draw the clipped image from the first temp canvas onto the final piece canvas, cropped
            finalPieceCtx.drawImage(tempCanvas, minX, minY, width, height, 0, 0, width, height);

            const pieceDataUrl = finalPieceCanvas.toDataURL('image/png');

            // Calculate average color
            const imageData = finalPieceCtx.getImageData(0, 0, width, height).data;
            let r = 0, g = 0, b = 0, a = 0;
            let pixelCount = 0;
            for (let i = 0; i < imageData.length; i += 4) {
                if (imageData[i + 3] > 0) { // Only count non-transparent pixels
                    r += imageData[i];
                    g += imageData[i + 1];
                    b += imageData[i + 2];
                    a += imageData[i + 3];
                    pixelCount++;
                }
            }
            const avgR = pixelCount > 0 ? Math.floor(r / pixelCount) : 0;
            const avgG = pixelCount > 0 ? Math.floor(g / pixelCount) : 0;
            const avgB = pixelCount > 0 ? Math.floor(b / pixelCount) : 0;
            const avgA = pixelCount > 0 ? (a / pixelCount / 255).toFixed(2) : 0; // Normalize alpha to 0-1

            const averageColor = `rgba(${avgR}, ${avgG}, ${avgB}, ${avgA})`;

            // Convert scaled path to original image coordinates for SVG recreation
            const originalCoordsPath = path.map(p => toOriginalImageCoords(p));

            // Load the piece image for efficient drawing on arrangementCanvas
            const pieceImageObject = new Image();
            pieceImageObject.src = pieceDataUrl;
            await new Promise(resolve => pieceImageObject.onload = resolve); // Ensure image is loaded

            const pieceId = 'piece-' + Date.now(); // Unique ID for the piece
            const newPieceData = {
                id: pieceId,
                imageDataUrl: pieceDataUrl,
                imageObject: pieceImageObject,
                originalPath: originalCoordsPath,
                averageColor: averageColor,
                x: 0, // Initial position on arrangement canvas
                y: 0,
                width: pieceImageObject.width,
                height: pieceImageObject.height
            };

            extractedPiecesData.push(newPieceData);
            displayPieceInfo(newPieceData);
            redrawMainCanvasPaths(); // Redraw main canvas without the just-cut path
            redrawArrangementCanvas(); // Redraw arrangement canvas with new piece

            showMessageBox('Piece cut successfully! Drag its info from the left panel to the right canvas.', 'info');
        });

        /**
         * Displays extracted piece information in the info panel.
         * Makes the info draggable for placing on arrangement canvas.
         * @param {Object} pieceData - The data for the extracted piece.
         */
        function displayPieceInfo(pieceData) {
            // Remove the initial instruction message if pieces are being added
            const initialMessage = pieceInfoPanel.querySelector('p.text-gray-500');
            if (initialMessage) {
                pieceInfoPanel.removeChild(initialMessage);
            }

            const infoDiv = document.createElement('div');
            infoDiv.className = 'bg-white rounded-md p-3 mb-3 shadow-sm cursor-grab border border-indigo-200 hover:border-indigo-400 transition-all';
            infoDiv.id = `info-${pieceData.id}`;
            infoDiv.setAttribute('draggable', 'true');
            infoDiv.dataset.pieceId = pieceData.id;

            let pathSvgString = '';
            if (pieceData.originalPath && pieceData.originalPath.length > 0) {
                pathSvgString = `M ${pieceData.originalPath[0].x} ${pieceData.originalPath[0].y}`;
                for (let i = 1; i < pieceData.originalPath.length; i++) {
                    pathSvgString += ` L ${pieceData.originalPath[i].x} ${pieceData.originalPath[i].y}`;
                }
                pathSvgString += ' Z'; // Close path
            }

            infoDiv.innerHTML = `
                <h4 class="font-semibold text-indigo-800">Piece ID: ${pieceData.id.split('-')[1]}</h4>
                <p><strong>Avg Color:</strong> <span style="background-color: ${pieceData.averageColor}; padding: 2px 5px; border-radius: 3px;">${pieceData.averageColor}</span></p>
                <p><strong>Original Coords:</strong> (Relative to original image)</p>
                <code class="block overflow-auto text-xs max-h-20">${pathSvgString}</code>
                <p class="text-sm text-gray-600 mt-2">Drag this info box to place the piece on the right canvas.</p>
            `;
            pieceInfoPanel.appendChild(infoDiv);

            // Add drag event listeners for piece info
            infoDiv.addEventListener('dragstart', (e) => {
                draggedPieceId = pieceData.id;
                // Store a dummy data to allow dragging. Actual data transfer isn't needed here.
                e.dataTransfer.setData('text/plain', draggedPieceId);
                e.dataTransfer.effectAllowed = 'copyMove';
                infoDiv.classList.add('opacity-50'); // Visual feedback for dragged item
            });

            infoDiv.addEventListener('dragend', () => {
                draggedPieceId = null;
                infoDiv.classList.remove('opacity-50');
            });
        }

        // Drag and Drop for arrangementCanvas
        arrangementCanvas.addEventListener('dragover', (e) => {
            e.preventDefault(); // Allow drop
            e.dataTransfer.dropEffect = 'copyMove';

            // Visual feedback for drag over
            if (!lastHoveredElement) {
                arrangementCanvas.style.borderColor = '#6366f1'; /* indigo-500 */
                arrangementCanvas.style.boxShadow = '0 0 0 4px rgba(99, 102, 241, 0.5)';
                lastHoveredElement = arrangementCanvas;
            }
        });

        arrangementCanvas.addEventListener('dragleave', () => {
            // Reset visual feedback
            if (lastHoveredElement === arrangementCanvas) {
                arrangementCanvas.style.borderColor = '';
                arrangementCanvas.style.boxShadow = '';
                lastHoveredElement = null;
            }
        });

        arrangementCanvas.addEventListener('drop', (e) => {
            e.preventDefault();
            // Reset visual feedback
            arrangementCanvas.style.borderColor = '';
            arrangementCanvas.style.boxShadow = '';
            lastHoveredElement = null;

            if (draggedPieceId) {
                const piece = extractedPiecesData.find(p => p.id === draggedPieceId);
                if (piece) {
                    const canvasRect = arrangementCanvas.getBoundingClientRect();
                    const dropX = e.clientX - canvasRect.left;
                    const dropY = e.clientY - canvasRect.top;

                    // Calculate position on the *internal* canvas coordinates
                    const internalX = dropX * (arrangementCanvas.width / canvasRect.width);
                    const internalY = dropY * (arrangementCanvas.height / canvasRect.height);

                    // Center the piece where it's dropped initially, then adjust for snapping
                    piece.x = internalX - piece.width / 2;
                    piece.y = internalY - piece.height / 2;

                    applySnapping(piece);
                    redrawArrangementCanvas();
                }
            }
        });

        /**
         * Applies snapping logic to a dragged piece.
         * @param {Object} currentPiece - The piece being snapped.
         */
        function applySnapping(currentPiece) {
            extractedPiecesData.forEach(otherPiece => {
                if (currentPiece.id === otherPiece.id) return; // Don't snap to itself

                // Check horizontal snapping
                // Snap left edge of current to right edge of other
                if (Math.abs(currentPiece.x - (otherPiece.x + otherPiece.width)) < SNAPPING_THRESHOLD) {
                    currentPiece.x = otherPiece.x + otherPiece.width;
                }
                // Snap right edge of current to left edge of other
                else if (Math.abs((currentPiece.x + currentPiece.width) - otherPiece.x) < SNAPPING_THRESHOLD) {
                    currentPiece.x = otherPiece.x - currentPiece.width;
                }
                // Snap left edge of current to left edge of other
                else if (Math.abs(currentPiece.x - otherPiece.x) < SNAPPING_THRESHOLD) {
                    currentPiece.x = otherPiece.x;
                }
                // Snap right edge of current to right edge of other
                else if (Math.abs((currentPiece.x + currentPiece.width) - (otherPiece.x + otherPiece.width)) < SNAPPING_THRESHOLD) {
                    currentPiece.x = otherPiece.x + otherPiece.width - currentPiece.width;
                }


                // Check vertical snapping
                // Snap top edge of current to bottom edge of other
                if (Math.abs(currentPiece.y - (otherPiece.y + otherPiece.height)) < SNAPPING_THRESHOLD) {
                    currentPiece.y = otherPiece.y + otherPiece.height;
                }
                // Snap bottom edge of current to top edge of other
                else if (Math.abs((currentPiece.y + currentPiece.height) - otherPiece.y) < SNAPPING_THRESHOLD) {
                    currentPiece.y = otherPiece.y - currentPiece.height;
                }
                // Snap top edge of current to top edge of other
                else if (Math.abs(currentPiece.y - otherPiece.y) < SNAPPING_THRESHOLD) {
                    currentPiece.y = otherPiece.y;
                }
                // Snap bottom edge of current to bottom edge of other
                else if (Math.abs((currentPiece.y + currentPiece.height) - (otherPiece.y + otherPiece.height)) < SNAPPING_THRESHOLD) {
                    currentPiece.y = otherPiece.y + otherPiece.height - currentPiece.height;
                }
            });

            // Boundary snapping (optional, but good for keeping pieces on canvas)
            currentPiece.x = Math.max(0, Math.min(currentPiece.x, arrangementCanvas.width - currentPiece.width));
            currentPiece.y = Math.max(0, Math.min(currentPiece.y, arrangementCanvas.height - currentPiece.height));
        }

        // In-canvas drag for existing pieces on arrangementCanvas
        arrangementCanvas.addEventListener('mousedown', (e) => {
            const coords = getCanvasCoordinates(e, arrangementCanvas);
            // Iterate through pieces in reverse order to pick the topmost one
            for (let i = extractedPiecesData.length - 1; i >= 0; i--) {
                const piece = extractedPiecesData[i];
                if (coords.x >= piece.x && coords.x <= piece.x + piece.width &&
                    coords.y >= piece.y && coords.y <= piece.y + piece.height) {
                    
                    draggedPieceId = piece.id;
                    // Move the dragged piece to the end of the array to draw it on top
                    extractedPiecesData.splice(i, 1);
                    extractedPiecesData.push(piece);

                    dragOffsetX = coords.x - piece.x;
                    dragOffsetY = coords.y - piece.y;
                    break;
                }
            }
        });

        arrangementCanvas.addEventListener('mousemove', (e) => {
            if (draggedPieceId) {
                const piece = extractedPiecesData.find(p => p.id === draggedPieceId);
                if (piece) {
                    const coords = getCanvasCoordinates(e, arrangementCanvas);
                    piece.x = coords.x - dragOffsetX;
                    piece.y = coords.y - dragOffsetY;
                    redrawArrangementCanvas(); // Redraw frequently during drag
                }
            }
        });

        arrangementCanvas.addEventListener('mouseup', () => {
            if (draggedPieceId) {
                const piece = extractedPiecesData.find(p => p.id === draggedPieceId);
                if (piece) {
                    applySnapping(piece); // Apply snapping once dragging ends
                    redrawArrangementCanvas();
                }
                draggedPieceId = null;
            }
        });

        arrangementCanvas.addEventListener('mouseleave', () => {
             if (draggedPieceId) {
                const piece = extractedPiecesData.find(p => p.id === draggedPieceId);
                if (piece) {
                    applySnapping(piece); // Apply snapping if mouse leaves canvas
                    redrawArrangementCanvas();
                }
                draggedPieceId = null;
            }
        });

        // Touch events for in-canvas drag
        arrangementCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent scrolling
            const coords = getCanvasCoordinates(e, arrangementCanvas);
             for (let i = extractedPiecesData.length - 1; i >= 0; i--) {
                const piece = extractedPiecesData[i];
                if (coords.x >= piece.x && coords.x <= piece.x + piece.width &&
                    coords.y >= piece.y && coords.y <= piece.y + piece.height) {
                    
                    draggedPieceId = piece.id;
                    extractedPiecesData.splice(i, 1);
                    extractedPiecesData.push(piece); // Bring to front

                    dragOffsetX = coords.x - piece.x;
                    dragOffsetY = coords.y - piece.y;
                    break;
                }
            }
        }, { passive: false });

        arrangementCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Prevent scrolling
            if (draggedPieceId) {
                const piece = extractedPiecesData.find(p => p.id === draggedPieceId);
                if (piece) {
                    const coords = getCanvasCoordinates(e, arrangementCanvas);
                    piece.x = coords.x - dragOffsetX;
                    piece.y = coords.y - dragOffsetY;
                    redrawArrangementCanvas();
                }
            }
        }, { passive: false });

        arrangementCanvas.addEventListener('touchend', () => {
            if (draggedPieceId) {
                const piece = extractedPiecesData.find(p => p.id === draggedPieceId);
                if (piece) {
                    applySnapping(piece);
                    redrawArrangementCanvas();
                }
                draggedPieceId = null;
            }
        });

        arrangementCanvas.addEventListener('touchcancel', () => {
            if (draggedPieceId) {
                const piece = extractedPiecesData.find(p => p.id === draggedPieceId);
                if (piece) {
                    applySnapping(piece);
                    redrawArrangementCanvas();
                }
                draggedPieceId = null;
            }
        });


        /**
         * Saves all extracted pieces as individual PNG files.
         */
        saveAllButton.addEventListener('click', () => {
            if (extractedPiecesData.length === 0) {
                showMessageBox('No pieces to save! Please cut some pieces first.', 'error');
                return;
            }

            extractedPiecesData.forEach((pieceData, index) => {
                const link = document.createElement('a');
                link.href = pieceData.imageDataUrl;
                link.download = `cut_piece_${index + 1}.png`;
                document.body.appendChild(link); // Append to body to make it clickable
                link.click(); // Programmatically click the link to trigger download
                document.body.removeChild(link); // Remove after click
            });
            showMessageBox('All pieces saved successfully!', 'info');
        });

        /**
         * Downloads the current content of the arrangement canvas as a PNG.
         */
        downloadArrangementButton.addEventListener('click', () => {
            if (!originalImage || (extractedPiecesData.length === 0 && arrangementCanvas.width === 0)) {
                showMessageBox('Nothing to download. Please upload an image and/or arrange pieces.', 'error');
                return;
            }
            if (arrangementCanvas.width === 0 || arrangementCanvas.height === 0) {
                showMessageBox('Arrangement canvas is not ready. Please upload an image first.', 'error');
                return;
            }

            const link = document.createElement('a');
            link.href = arrangementCanvas.toDataURL('image/png');
            link.download = 'arranged_image.png';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            showMessageBox('Arranged image downloaded successfully!', 'info');
        });


        // Reset Button Event Listener
        resetButton.addEventListener('click', resetApp);

        // Initial setup on window load
        window.onload = () => {
            resetApp(); // Ensure initial state is clean and buttons are disabled
        };
    </script>
</body>
</html>
